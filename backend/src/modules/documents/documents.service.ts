import { Injectable } from '@nestjs/common';
import * as PDFDocument from 'pdfkit';
import * as archiver from 'archiver';
import { Notice } from '../notices/entities/notice.entity';
import { Claim } from '../notices/entities/claim.entity';
import { Evidence } from '../evidence/entities/evidence.entity';

@Injectable()
export class DocumentsService {
  async generateNoticePDF(notice: Notice, projectName: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const doc = new (PDFDocument as any)({ margin: 50 });
      const chunks: Buffer[] = [];

      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      doc.fontSize(20).text('NOTICE OF DELAY/VARIATION', { align: 'center' });
      doc.moveDown();

      // Project Information
      doc.fontSize(12).text(`Project: ${projectName}`, { align: 'left' });
      doc.text(`Notice ID: ${notice.id}`, { align: 'left' });
      doc.text(`Date: ${new Date().toLocaleDateString()}`, { align: 'left' });
      doc.moveDown();

      // Notice Type
      doc.fontSize(14).text(`Type: ${notice.noticeType.toUpperCase()}`, { underline: true });
      doc.moveDown();

      // Clause Reference
      if (notice.clauseReference) {
        doc.fontSize(12).text(`Clause Reference: ${notice.clauseReference}`);
        doc.moveDown();
      }

      // Event Date
      doc.text(`Event Date: ${new Date(notice.eventDate).toLocaleDateString()}`);
      doc.moveDown();

      // Description
      doc.fontSize(12).text('Description:', { underline: true });
      doc.moveDown(0.5);
      doc.fontSize(11).text(notice.description, { align: 'justify' });
      doc.moveDown();

      // AI Generated Content
      if (notice.aiGeneratedContent) {
        doc.fontSize(12).text('Notice Content:', { underline: true });
        doc.moveDown(0.5);
        doc.fontSize(11).text(notice.aiGeneratedContent, { align: 'justify' });
        doc.moveDown();
      }

      // Time Bar Deadline
      if (notice.timeBarDeadline) {
        doc.fontSize(10)
          .fillColor('red')
          .text(
            `Time Bar Deadline: ${new Date(notice.timeBarDeadline).toLocaleDateString()}`,
            { align: 'right' },
          );
        doc.fillColor('black');
      }

      // Footer
      doc.fontSize(8)
        .text('This notice is issued in accordance with the contract terms.', {
          align: 'center',
        })
        .text(`Generated by Za-Eng Construction Platform on ${new Date().toLocaleString()}`, {
          align: 'center',
        });

      doc.end();
    });
  }

  async generateClaimPack(
    claim: Claim,
    notice: Notice,
    evidenceList: Evidence[],
    projectName: string,
  ): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const archive = archiver('zip', { zlib: { level: 9 } });
      const chunks: Buffer[] = [];

      archive.on('data', (chunk) => chunks.push(chunk));
      archive.on('end', () => resolve(Buffer.concat(chunks)));
      archive.on('error', reject);

      // Add notice PDF
      this.generateNoticePDF(notice, projectName).then((noticePdf) => {
        archive.append(noticePdf, { name: 'Notice.pdf' });

        // Add claim summary
        const claimSummary = this.generateClaimSummary(claim, notice);
        archive.append(claimSummary, { name: 'Claim_Summary.txt' });

        // Add evidence files (if URLs are available)
        evidenceList.forEach((evidence, index) => {
          if (evidence.fileUrl) {
            archive.append(`Evidence ${index + 1}: ${evidence.title}\nURL: ${evidence.fileUrl}`, {
              name: `Evidence_${index + 1}_${evidence.title}.txt`,
            });
          }
        });

        // Add chronology
        const chronology = this.generateChronology(notice, claim, evidenceList);
        archive.append(chronology, { name: 'Chronology.txt' });

        archive.finalize();
      });
    });
  }

  private generateClaimSummary(claim: Claim, notice: Notice): string {
    return `
CLAIM SUMMARY
=============

Claim Title: ${claim.title}
Claim ID: ${claim.id}
Notice Reference: ${notice.id}

Status: ${claim.status}
Created: ${new Date(claim.createdAt).toLocaleString()}

Days Requested: ${claim.daysRequested || 'N/A'}
Days Approved: ${claim.daysApproved || 'Pending'}
Amount Requested: R${claim.amountRequested?.toLocaleString() || 'N/A'}
Amount Approved: R${claim.amountApproved?.toLocaleString() || 'Pending'}

Description:
${claim.description || notice.description}

---
Generated by Za-Eng Construction Platform
${new Date().toLocaleString()}
`;
  }

  private generateChronology(
    notice: Notice,
    claim: Claim,
    evidenceList: Evidence[],
  ): string {
    const events = [
      {
        date: notice.eventDate,
        description: `Event occurred: ${notice.description}`,
      },
      {
        date: notice.createdAt,
        description: `Notice created: ${notice.title}`,
      },
      {
        date: notice.sentAt || notice.createdAt,
        description: `Notice sent to client`,
      },
      {
        date: claim.createdAt,
        description: `Claim created: ${claim.title}`,
      },
      {
        date: claim.sentAt || claim.createdAt,
        description: `Claim submitted`,
      },
    ];

    if (claim.approvedAt) {
      events.push({
        date: claim.approvedAt,
        description: `Claim approved: ${claim.daysApproved} days, R${claim.amountApproved}`,
      });
    }

    if (claim.rejectedAt) {
      events.push({
        date: claim.rejectedAt,
        description: `Claim rejected: ${claim.rejectionReason}`,
      });
    }

    events.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    let chronology = 'CHRONOLOGY OF EVENTS\n';
    chronology += '===================\n\n';

    events.forEach((event, index) => {
      chronology += `${index + 1}. ${new Date(event.date).toLocaleDateString()}\n`;
      chronology += `   ${event.description}\n\n`;
    });

    if (evidenceList.length > 0) {
      chronology += '\nEVIDENCE DOCUMENTS:\n';
      chronology += '===================\n\n';
      evidenceList.forEach((evidence, index) => {
        chronology += `${index + 1}. ${evidence.title}\n`;
        chronology += `   Uploaded: ${new Date(evidence.createdAt).toLocaleDateString()}\n`;
        if (evidence.category) {
          chronology += `   Category: ${evidence.category}\n`;
        }
        chronology += '\n';
      });
    }

    chronology += `\n---\nGenerated by Za-Eng Construction Platform\n${new Date().toLocaleString()}`;

    return chronology;
  }
}

